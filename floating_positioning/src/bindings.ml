[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Core
open! Js_of_ocaml
open! Gen_js_api
open Custom_converters

module Alignment = struct
  type t =
    | Start
    | End
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x2 : Ojs.t) ->
    let x3 = x2 in
    match Ojs.string_of_js x3 with
    | "start" -> Start
    | "end" -> End
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x1 : t) ->
    match x1 with
    | Start -> Ojs.string_to_js "start"
    | End -> Ojs.string_to_js "end"
  ;;
end

module Placement = struct
  type t =
    | Top
    | Top_start
    | Top_end
    | Bottom
    | Bottom_start
    | Bottom_end
    | Right
    | Right_start
    | Right_end
    | Left
    | Left_start
    | Left_end
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x5 : Ojs.t) ->
    let x6 = x5 in
    match Ojs.string_of_js x6 with
    | "top" -> Top
    | "top-start" -> Top_start
    | "top-end" -> Top_end
    | "bottom" -> Bottom
    | "bottom-start" -> Bottom_start
    | "bottom-end" -> Bottom_end
    | "right" -> Right
    | "right-start" -> Right_start
    | "right-end" -> Right_end
    | "left" -> Left
    | "left-start" -> Left_start
    | "left-end" -> Left_end
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x4 : t) ->
    match x4 with
    | Top -> Ojs.string_to_js "top"
    | Top_start -> Ojs.string_to_js "top-start"
    | Top_end -> Ojs.string_to_js "top-end"
    | Bottom -> Ojs.string_to_js "bottom"
    | Bottom_start -> Ojs.string_to_js "bottom-start"
    | Bottom_end -> Ojs.string_to_js "bottom-end"
    | Right -> Ojs.string_to_js "right"
    | Right_start -> Ojs.string_to_js "right-start"
    | Right_end -> Ojs.string_to_js "right-end"
    | Left -> Ojs.string_to_js "left"
    | Left_start -> Ojs.string_to_js "left-start"
    | Left_end -> Ojs.string_to_js "left-end"
  ;;
end

module Strategy = struct
  type t =
    | Absolute
    | Fixed
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x8 : Ojs.t) ->
    let x9 = x8 in
    match Ojs.string_of_js x9 with
    | "absolute" -> Absolute
    | "fixed" -> Fixed
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x7 : t) ->
    match x7 with
    | Absolute -> Ojs.string_to_js "absolute"
    | Fixed -> Ojs.string_to_js "fixed"
  ;;
end

module Offset = struct
  type t =
    { main_axis : float
    ; cross_axis : float
    }
  [@@deriving sexp, sexp_grammar, equal, compare]

  let rec t_of_js : Ojs.t -> t =
    fun (x11 : Ojs.t) ->
    { main_axis = Ojs.float_of_js (Ojs.get_prop_ascii x11 "mainAxis")
    ; cross_axis = Ojs.float_of_js (Ojs.get_prop_ascii x11 "crossAxis")
    }

  and t_to_js : t -> Ojs.t =
    fun (x10 : t) ->
    Ojs.obj
      [| "mainAxis", Ojs.float_to_js x10.main_axis
       ; "crossAxis", Ojs.float_to_js x10.cross_axis
      |]
  ;;
end

module Middleware = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x13 : Ojs.t) -> x13
  and t_to_js : t -> Ojs.t = fun (x12 : Ojs.t) -> x12

  module Offset = struct
    let create : Offset.t -> t =
      fun (x14 : Offset.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "offset"
           [| Offset.t_to_js x14 |])
    ;;
  end

  module Size = struct
    module Options = struct
      module Apply_options = struct
        type t =
          { available_width : float
          ; available_height : float
          }

        let rec t_of_js : Ojs.t -> t =
          fun (x16 : Ojs.t) ->
          { available_width = Ojs.float_of_js (Ojs.get_prop_ascii x16 "availableWidth")
          ; available_height = Ojs.float_of_js (Ojs.get_prop_ascii x16 "availableHeight")
          }

        and t_to_js : t -> Ojs.t =
          fun (x15 : t) ->
          Ojs.obj
            [| "availableWidth", Ojs.float_to_js x15.available_width
             ; "availableHeight", Ojs.float_to_js x15.available_height
            |]
        ;;
      end

      type t = { apply : Apply_options.t -> unit }

      let rec t_of_js : Ojs.t -> t =
        fun (x19 : Ojs.t) ->
        { apply =
            (fun (x20 : Apply_options.t) ->
              ignore
                (Ojs.apply
                   (Ojs.get_prop_ascii x19 "apply")
                   [| Apply_options.t_to_js x20 |]))
        }

      and t_to_js : t -> Ojs.t =
        fun (x17 : t) ->
        Ojs.obj
          [| ( "apply"
             , Ojs.fun_to_js 1 (fun (x18 : Ojs.t) ->
                 x17.apply (Apply_options.t_of_js x18)) )
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x21 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "size"
           [| Options.t_to_js x21 |])
    ;;
  end

  module Flip = struct
    module Options = struct
      type t = { padding : float option }

      let rec t_of_js : Ojs.t -> t =
        fun (x24 : Ojs.t) ->
        { padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x24 "padding") }

      and t_to_js : t -> Ojs.t =
        fun (x22 : t) ->
        Ojs.obj [| "padding", Ojs.option_to_js Ojs.float_to_js x22.padding |]
      ;;
    end

    let create : Options.t -> t =
      fun (x26 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "flip"
           [| Options.t_to_js x26 |])
    ;;
  end

  module Shift = struct
    module Limiter = struct
      module Options = struct
        type t =
          { main_axis : bool
          ; cross_axis : bool
          }

        let rec t_of_js : Ojs.t -> t =
          fun (x28 : Ojs.t) ->
          { main_axis = Ojs.bool_of_js (Ojs.get_prop_ascii x28 "mainAxis")
          ; cross_axis = Ojs.bool_of_js (Ojs.get_prop_ascii x28 "crossAxis")
          }

        and t_to_js : t -> Ojs.t =
          fun (x27 : t) ->
          Ojs.obj
            [| "mainAxis", Ojs.bool_to_js x27.main_axis
             ; "crossAxis", Ojs.bool_to_js x27.cross_axis
            |]
        ;;
      end

      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x30 : Ojs.t) -> x30
      and t_to_js : t -> Ojs.t = fun (x29 : Ojs.t) -> x29

      let create : Options.t -> t =
        fun (x31 : Options.t) ->
        t_of_js
          (Ojs.call
             (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
             "limitShift"
             [| Options.t_to_js x31 |])
      ;;
    end

    module Options = struct
      type t =
        { padding : float option
        ; limiter : Limiter.t
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x34 : Ojs.t) ->
        { padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x34 "padding")
        ; limiter = Limiter.t_of_js (Ojs.get_prop_ascii x34 "limiter")
        }

      and t_to_js : t -> Ojs.t =
        fun (x32 : t) ->
        Ojs.obj
          [| "padding", Ojs.option_to_js Ojs.float_to_js x32.padding
           ; "limiter", Limiter.t_to_js x32.limiter
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x36 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "shift"
           [| Options.t_to_js x36 |])
    ;;
  end

  module Auto_placement = struct
    module Options = struct
      type t =
        { alignment : Alignment.t option
        ; padding : float option
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x40 : Ojs.t) ->
        { alignment =
            Ojs.option_of_js Alignment.t_of_js (Ojs.get_prop_ascii x40 "alignment")
        ; padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x40 "padding")
        }

      and t_to_js : t -> Ojs.t =
        fun (x37 : t) ->
        Ojs.obj
          [| "alignment", Ojs.option_to_js Alignment.t_to_js x37.alignment
           ; "padding", Ojs.option_to_js Ojs.float_to_js x37.padding
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x43 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "autoPlacement"
           [| Options.t_to_js x43 |])
    ;;
  end

  module Arrow = struct
    module Options = struct
      type t =
        { element : Dom_html.element Js.t
        ; padding : float option
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x47 : Ojs.t) ->
        { element = Js.t_of_js Dom_html.element_of_js (Ojs.get_prop_ascii x47 "element")
        ; padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x47 "padding")
        }

      and t_to_js : t -> Ojs.t =
        fun (x44 : t) ->
        Ojs.obj
          [| "element", Js.t_to_js Dom_html.element_to_js x44.element
           ; "padding", Ojs.option_to_js Ojs.float_to_js x44.padding
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x50 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "arrow"
           [| Options.t_to_js x50 |])
    ;;
  end
end

module Reference_element = struct
  module Client_rect_object = struct
    type t =
      { width : float
      ; height : float
      ; x : float
      ; y : float
      ; top : float
      ; left : float
      ; right : float
      ; bottom : float
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x52 : Ojs.t) ->
      { width = Ojs.float_of_js (Ojs.get_prop_ascii x52 "width")
      ; height = Ojs.float_of_js (Ojs.get_prop_ascii x52 "height")
      ; x = Ojs.float_of_js (Ojs.get_prop_ascii x52 "x")
      ; y = Ojs.float_of_js (Ojs.get_prop_ascii x52 "y")
      ; top = Ojs.float_of_js (Ojs.get_prop_ascii x52 "top")
      ; left = Ojs.float_of_js (Ojs.get_prop_ascii x52 "left")
      ; right = Ojs.float_of_js (Ojs.get_prop_ascii x52 "right")
      ; bottom = Ojs.float_of_js (Ojs.get_prop_ascii x52 "bottom")
      }

    and t_to_js : t -> Ojs.t =
      fun (x51 : t) ->
      Ojs.obj
        [| "width", Ojs.float_to_js x51.width
         ; "height", Ojs.float_to_js x51.height
         ; "x", Ojs.float_to_js x51.x
         ; "y", Ojs.float_to_js x51.y
         ; "top", Ojs.float_to_js x51.top
         ; "left", Ojs.float_to_js x51.left
         ; "right", Ojs.float_to_js x51.right
         ; "bottom", Ojs.float_to_js x51.bottom
        |]
    ;;
  end

  module Virtual_element = struct
    type t = { get_bounding_client_rect : unit -> Client_rect_object.t }

    let rec t_of_js : Ojs.t -> t =
      fun (x54 : Ojs.t) ->
      { get_bounding_client_rect =
          (fun () ->
            Client_rect_object.t_of_js
              (Ojs.apply (Ojs.get_prop_ascii x54 "getBoundingClientRect") [||]))
      }

    and t_to_js : t -> Ojs.t =
      fun (x53 : t) ->
      Ojs.obj
        [| ( "getBoundingClientRect"
           , Ojs.fun_to_js 1 (fun _ ->
               Client_rect_object.t_to_js (x53.get_bounding_client_rect ())) )
        |]
    ;;
  end

  type t =
    [ `Virtual of Virtual_element.t
    | `Dom of Dom_html.element Js.t
    ]

  let rec t_to_js : t -> Ojs.t =
    fun (x55 : [ `Virtual of Virtual_element.t | `Dom of Dom_html.element Js.t ]) ->
    match x55 with
    | `Virtual x56 -> Virtual_element.t_to_js x56
    | `Dom x57 -> Js.t_to_js Dom_html.element_to_js x57
  ;;
end

module Compute_position = struct
  module Options = struct
    type t =
      { placement : Placement.t option
      ; strategy : Strategy.t
      ; middleware : Middleware.t list
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x65 : Ojs.t) ->
      { placement =
          Ojs.option_of_js Placement.t_of_js (Ojs.get_prop_ascii x65 "placement")
      ; strategy = Strategy.t_of_js (Ojs.get_prop_ascii x65 "strategy")
      ; middleware =
          Ojs.list_of_js Middleware.t_of_js (Ojs.get_prop_ascii x65 "middleware")
      }

    and t_to_js : t -> Ojs.t =
      fun (x62 : t) ->
      Ojs.obj
        [| "placement", Ojs.option_to_js Placement.t_to_js x62.placement
         ; "strategy", Strategy.t_to_js x62.strategy
         ; "middleware", Ojs.list_to_js Middleware.t_to_js x62.middleware
        |]
    ;;
  end

  module Then_args = struct
    type arrow =
      { x : float option
      ; y : float option
      }

    let rec arrow_of_js : Ojs.t -> arrow =
      fun (x71 : Ojs.t) ->
      { x = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x71 "x")
      ; y = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x71 "y")
      }

    and arrow_to_js : arrow -> Ojs.t =
      fun (x68 : arrow) ->
      Ojs.obj
        [| "x", Ojs.option_to_js Ojs.float_to_js x68.x
         ; "y", Ojs.option_to_js Ojs.float_to_js x68.y
        |]
    ;;

    type middleware_data = { arrow : arrow option }

    let rec middleware_data_of_js : Ojs.t -> middleware_data =
      fun (x76 : Ojs.t) ->
      { arrow = Ojs.option_of_js arrow_of_js (Ojs.get_prop_ascii x76 "arrow") }

    and middleware_data_to_js : middleware_data -> Ojs.t =
      fun (x74 : middleware_data) ->
      Ojs.obj [| "arrow", Ojs.option_to_js arrow_to_js x74.arrow |]
    ;;

    type t =
      { x : float
      ; y : float
      ; placement : Placement.t
      ; strategy : Strategy.t
      ; middleware_data : middleware_data option
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x80 : Ojs.t) ->
      { x = Ojs.float_of_js (Ojs.get_prop_ascii x80 "x")
      ; y = Ojs.float_of_js (Ojs.get_prop_ascii x80 "y")
      ; placement = Placement.t_of_js (Ojs.get_prop_ascii x80 "placement")
      ; strategy = Strategy.t_of_js (Ojs.get_prop_ascii x80 "strategy")
      ; middleware_data =
          Ojs.option_of_js middleware_data_of_js (Ojs.get_prop_ascii x80 "middlewareData")
      }

    and t_to_js : t -> Ojs.t =
      fun (x78 : t) ->
      Ojs.obj
        [| "x", Ojs.float_to_js x78.x
         ; "y", Ojs.float_to_js x78.y
         ; "placement", Placement.t_to_js x78.placement
         ; "strategy", Strategy.t_to_js x78.strategy
         ; "middlewareData", Ojs.option_to_js middleware_data_to_js x78.middleware_data
        |]
    ;;
  end

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x83 : Ojs.t) -> x83
  and t_to_js : t -> Ojs.t = fun (x82 : Ojs.t) -> x82

  let then_ : t -> (Then_args.t -> unit) -> unit =
    fun (x86 : t) (x84 : Then_args.t -> unit) ->
    ignore
      (Ojs.call
         (t_to_js x86)
         "then"
         [| Ojs.fun_to_js 1 (fun (x85 : Ojs.t) -> x84 (Then_args.t_of_js x85)) |])
  ;;

  let create
    : anchor:Reference_element.t -> floating:Dom_html.element Js.t -> Options.t -> t
    =
    fun ~anchor:(x87 : Reference_element.t)
        ~floating:(x88 : Dom_html.element Js.t)
        (x90 : Options.t) ->
    t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
         "computePosition"
         [| Reference_element.t_to_js x87
          ; Js.t_to_js Dom_html.element_to_js x88
          ; Options.t_to_js x90
         |])
  ;;
end

module Auto_update_handle = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x92 : Ojs.t) -> x92
  and t_to_js : t -> Ojs.t = fun (x91 : Ojs.t) -> x91

  let create
    :  anchor:Reference_element.t -> floating:Dom_html.element Js.t
    -> update:(unit -> unit) -> t
    =
    fun ~anchor:(x93 : Reference_element.t)
        ~floating:(x94 : Dom_html.element Js.t)
        ~update:(x96 : unit -> unit) ->
    t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
         "autoUpdate"
         [| Reference_element.t_to_js x93
          ; Js.t_to_js Dom_html.element_to_js x94
          ; Ojs.fun_to_js 1 (fun _ -> x96 ())
         |])
  ;;

  let cleanup : t -> unit = fun (x97 : t) -> ignore (Ojs.apply (t_to_js x97) [||])
end
